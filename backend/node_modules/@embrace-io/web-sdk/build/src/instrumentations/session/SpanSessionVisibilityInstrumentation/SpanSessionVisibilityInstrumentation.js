'use strict';

var EmbraceInstrumentationBase = require('../../EmbraceInstrumentationBase/EmbraceInstrumentationBase.js');
var throttle = require('../../../utils/throttle.js');
var bulkRemoveEventListener = require('../../../utils/bulkRemoveEventListener/bulkRemoveEventListener.js');
var bulkAddEventListener = require('../../../utils/bulkAddEventListener/bulkAddEventListener.js');

const SESSION_INTERACTION_EVENTS = [
    'mousedown'
];
class SpanSessionVisibilityInstrumentation extends EmbraceInstrumentationBase.EmbraceInstrumentationBase {
    constructor({ diag, perf, visibilityWaitTimeMs = 0, limitedSessionMaxDurationMs = 0, backgroundSessions = false, visibilityDoc = window.document } = {}){
        super({
            instrumentationName: 'SpanSessionVisibilityInstrumentation',
            instrumentationVersion: '1.0.0',
            diag,
            perf,
            config: {}
        });
        this._currentVisibilityState = visibilityDoc.visibilityState;
        this._checkVisibilityTimeout = null;
        this._interactionSinceLastVisibilityChange = false;
        this._avoidEndingLimitedSessions = limitedSessionMaxDurationMs > 0;
        this._checkVisibilityChange = ()=>{
            if (visibilityWaitTimeMs <= 0) {
                // If no timeout configured, events are forwarded directly.
                this._currentVisibilityState = visibilityDoc.visibilityState;
                this._onVisibilityChange();
                return;
            }
            if (this._checkVisibilityTimeout) {
                clearTimeout(this._checkVisibilityTimeout);
            }
            // When switching to visible, we want to trigger the event immediately
            if (visibilityDoc.visibilityState === 'visible' && this._currentVisibilityState != visibilityDoc.visibilityState) {
                this._currentVisibilityState = visibilityDoc.visibilityState;
                this._onVisibilityChange();
                return;
            }
            this._diag.debug(`Visibility changed to ${visibilityDoc.visibilityState}. Will wait ${(visibilityWaitTimeMs / 1000).toString()}s, and check if visibility changed`);
            this._checkVisibilityTimeout = setTimeout(()=>{
                if (this._currentVisibilityState != visibilityDoc.visibilityState) {
                    this._currentVisibilityState = visibilityDoc.visibilityState;
                    this._onVisibilityChange();
                } else {
                    this._diag.debug(`Visibility was not changed after timeout happened: ${visibilityDoc.visibilityState}`);
                }
            }, visibilityWaitTimeMs);
        };
        this._onVisibilityChange = ()=>{
            this._diag.debug(`Visibility change detected: ${visibilityDoc.visibilityState}`);
            const currentSessionStartTime = this.sessionManager.getSessionStartTime();
            // A limited session is one that is shorter than a specified duration threshold and contains no user interactions
            const isLimitedSession = this._avoidEndingLimitedSessions && currentSessionStartTime !== null && this.perf.millisSinceHRTime(currentSessionStartTime) < limitedSessionMaxDurationMs && !this._interactionSinceLastVisibilityChange;
            if (isLimitedSession) {
                this._diag.debug('Not ending the session since it is considered limited');
                // If this session still meets the definition of a limited session don't yet end it but instead just record
                // the visibility change as a breadcrumb
                this.sessionManager.addBreadcrumb(`Tab visibility changed to ${visibilityDoc.visibilityState}`);
            } else {
                this.sessionManager.endSessionSpanInternal('state_changed');
                if (visibilityDoc.visibilityState === 'hidden' && backgroundSessions) {
                    this._diag.debug('Starting a session since document visibility switched to hidden and `backgroundSessions` is enabled');
                    this.sessionManager.startSessionSpan({
                        reason: 'hidden'
                    });
                } else if (visibilityDoc.visibilityState === 'visible') {
                    this._diag.debug('Starting a session since document visibility switched to visible');
                    this.sessionManager.startSessionSpan({
                        reason: 'visible'
                    });
                }
            }
            this._interactionSinceLastVisibilityChange = false;
        };
        this._onInteractionThrottled = throttle.throttle(()=>{
            this._interactionSinceLastVisibilityChange = true;
        }, 1000);
        if (this._config.enabled) {
            this.enable();
        }
    }
    disable() {
        window.removeEventListener('visibilitychange', this._checkVisibilityChange);
        if (this._avoidEndingLimitedSessions) {
            bulkRemoveEventListener.bulkRemoveEventListener({
                target: window,
                events: SESSION_INTERACTION_EVENTS,
                callback: this._onInteractionThrottled
            });
        }
    }
    enable() {
        window.addEventListener('visibilitychange', this._checkVisibilityChange);
        if (this._avoidEndingLimitedSessions) {
            bulkAddEventListener.bulkAddEventListener({
                target: window,
                events: SESSION_INTERACTION_EVENTS,
                callback: this._onInteractionThrottled
            });
        }
    }
}

exports.SpanSessionVisibilityInstrumentation = SpanSessionVisibilityInstrumentation;
//# sourceMappingURL=SpanSessionVisibilityInstrumentation.js.map
