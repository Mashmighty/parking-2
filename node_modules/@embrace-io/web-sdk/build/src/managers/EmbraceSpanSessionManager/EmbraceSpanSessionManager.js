'use strict';

var api = require('@opentelemetry/api');
var incubating = require('@opentelemetry/semantic-conventions/incubating');
var constants = require('./constants.js');
var OTelPerformanceManager = require('../../utils/PerformanceManager/OTelPerformanceManager.js');
var attributes = require('../../constants/attributes.js');
var generateUUID = require('../../utils/generateUUID.js');
var EmbraceExtendedSpan = require('../EmbraceTraceManager/EmbraceExtendedSpan.js');

class EmbraceSpanSessionManager {
    constructor({ diag: diagParam, perf, visibilityDoc = window.document, storage = window.localStorage, limitManager }){
        this._activeSessionId = null;
        this._activeSessionStartTime = null;
        this._sessionSpan = null;
        this._activeSessionCounts = null;
        this._coldStart = true; // Whether the session was started from a new page load or not.
        this._startupDuration = 0;
        this._sessionStartedListeners = [];
        this._sessionEndedListeners = [];
        this._diag = diagParam ?? api.diag.createComponentLogger({
            namespace: 'EmbraceSpanSessionManager'
        });
        this._perf = perf ?? new OTelPerformanceManager.OTelPerformanceManager();
        this._visibilityDoc = visibilityDoc;
        this._storage = storage;
        this._limitManager = limitManager;
    }
    // retrieve permanent properties from localStorage
    _getPermanentAttributes() {
        const permanentAttributes = new Map();
        try {
            for(let i = 0; i < this._storage.length; i++){
                const key = this._storage.key(i);
                if (key?.startsWith(attributes.KEY_PREFIX_EMB_PROPERTIES)) {
                    const value = this._storage.getItem(key);
                    if (value) {
                        permanentAttributes.set(key, value);
                    }
                }
            }
        } catch (error) {
            this._diag.warn('Error loading permanent session properties', error);
        }
        return Object.fromEntries(permanentAttributes.entries());
    }
    // Increment and return the session number stored in local storage.
    // This is not perfect in the sense that there may be a race condition between tabs.
    // Eventually a lock could be implemented, but for now this solution should work fine.
    _getSessionNumber() {
        const value = this._storage.getItem(constants.EMBRACE_SESSION_NUMBER_STORAGE_KEY);
        let number = value ? parseInt(value, 10) : 0;
        number++;
        this._storage.setItem(constants.EMBRACE_SESSION_NUMBER_STORAGE_KEY, number.toString());
        return number;
    }
    addBreadcrumb(name) {
        if (!this._sessionSpan) {
            this._diag.debug('trying to add breadcrumb to a session, but there is no session in progress. This is a no-op.');
            return;
        }
        const limitedBreadcrumb = this._limitManager.limitBreadcrumb(name);
        if (limitedBreadcrumb === 'dropped') {
            return;
        }
        this._sessionSpan.addEvent('emb-breadcrumb', {
            message: limitedBreadcrumb.name
        }, this._perf.getNowMillis());
    }
    addProperty(propertyKey, value, options) {
        if (!this._sessionSpan) {
            this._diag.debug('trying to add properties to a session, but there is no session in progress. This is a no-op.');
            return;
        }
        const limitedSessionProperty = this._limitManager.limitSessionProperty(propertyKey, value);
        if (limitedSessionProperty === 'dropped') {
            return;
        }
        const attributeKey = attributes.KEY_PREFIX_EMB_PROPERTIES + limitedSessionProperty.key;
        this._sessionSpan.setAttribute(attributeKey, limitedSessionProperty.value);
        if (options?.lifespan === 'permanent') {
            try {
                this._storage.setItem(attributeKey, value);
            } catch (error) {
                this._diag.warn('Failed to set permanent session property', error);
            }
        }
    }
    removeProperty(propertyKey) {
        if (!this._sessionSpan) {
            this._diag.debug('trying to remove a session property, but there is no session in progress. This is a no-op.');
            return;
        }
        // We truncate long session property keys on addProperty so need to apply the same logic here
        const attributeKey = attributes.KEY_PREFIX_EMB_PROPERTIES + this._limitManager.truncateString('session_property_key', propertyKey);
        this._sessionSpan.removeAttribute(attributeKey);
        try {
            if (this._storage.getItem(attributeKey)) {
                this._storage.removeItem(attributeKey);
            }
        } catch (error) {
            this._diag.warn('Error removing permanent session property', error);
        }
    }
    // the external api doesn't include a reason, and if a users uses it to end a session, the reason will be 'manual'
    // note: don't use this internally, this is just for user facing APIs. Use this.endSessionSpanInternal instead.
    endSessionSpan() {
        this.endSessionSpanInternal('manual');
    }
    // endSessionSpanInternal is not part of the public API, but is used internally to end a session span adding a specific reason
    endSessionSpanInternal(reason) {
        if (!this._sessionSpan) {
            this._diag.debug('trying to end a session, but there is no session in progress. This is a no-op.');
            return;
        }
        this._sessionSpan.setAttributes({
            ...this._getPermanentAttributes(),
            [attributes.KEY_EMB_SESSION_REASON_ENDED]: reason,
            ...this._activeSessionCounts,
            ...this._limitManager.getDiagnosticCounts(),
            [attributes.KEY_EMB_STARTUP_DURATION]: this._startupDuration
        });
        this._sessionSpan.end();
        this._sessionSpan = null;
        this._activeSessionStartTime = null;
        this._activeSessionId = null;
        this._activeSessionCounts = null;
        for (const listener of this._sessionEndedListeners){
            try {
                listener();
            } catch (error) {
                this._diag.warn('Error while executing session ended listener', error);
            }
        }
        // For the limit manager to add a session ended listener it would need a reference to this
        // session manager which would create a circular dependency
        this._limitManager.reset();
    }
    getSessionId() {
        return this._activeSessionId;
    }
    getSessionSpan() {
        return this._sessionSpan;
    }
    getSessionStartTime() {
        return this._activeSessionStartTime;
    }
    startSessionSpan(options) {
        // if there is a session already in progress, end it first
        if (this._sessionSpan) {
            this.endSessionSpanInternal('manual');
        }
        const tracer = api.trace.getTracer('embrace-web-sdk-sessions');
        this._activeSessionId = generateUUID.generateUUID();
        this._activeSessionStartTime = this._perf.getNowHRTime();
        this._activeSessionCounts = {};
        const attributes$1 = {
            ...this._getPermanentAttributes(),
            [attributes.KEY_EMB_TYPE]: attributes.EMB_TYPES.Session,
            [attributes.KEY_EMB_STATE]: this._visibilityDoc.visibilityState === 'hidden' ? attributes.EMB_STATES.Background : attributes.EMB_STATES.Foreground,
            [incubating.ATTR_SESSION_ID]: this._activeSessionId,
            [attributes.KEY_EMB_COLD_START]: this._coldStart,
            [attributes.KEY_EMB_SESSION_NUMBER]: this._getSessionNumber()
        };
        if (options?.reason) {
            attributes$1[attributes.KEY_EMB_SESSION_REASON_STARTED] = options.reason;
        }
        this._sessionSpan = new EmbraceExtendedSpan.EmbraceExtendedSpan(tracer.startSpan('emb-session', {
            attributes: attributes$1
        }));
        this._coldStart = false;
        for (const listener of this._sessionStartedListeners){
            try {
                listener();
            } catch (error) {
                this._diag.warn('Error while executing session started listener', error);
            }
        }
    }
    incrSessionCountForKey(key) {
        if (!this._sessionSpan || !this._activeSessionCounts) {
            this._diag.debug('trying to increment a count for the active session, but there is no session in progress. This is a no-op.');
            return;
        }
        this._activeSessionCounts[key] = (this._activeSessionCounts[key] || 0) + 1;
    }
    addSessionStartedListener(listener) {
        const listenerIndex = this._sessionStartedListeners.push(listener);
        return ()=>{
            this._sessionStartedListeners.splice(listenerIndex - 1, 1);
        };
    }
    addSessionEndedListener(listener) {
        const listenerIndex = this._sessionEndedListeners.push(listener);
        return ()=>{
            this._sessionEndedListeners.splice(listenerIndex - 1, 1);
        };
    }
    recordStartupDuration(duration) {
        this._startupDuration = duration;
    }
}

exports.EmbraceSpanSessionManager = EmbraceSpanSessionManager;
//# sourceMappingURL=EmbraceSpanSessionManager.js.map
