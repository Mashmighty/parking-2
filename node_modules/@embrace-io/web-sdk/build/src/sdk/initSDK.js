'use strict';

var api = require('@opentelemetry/api');
var apiLogs = require('@opentelemetry/api-logs');
var instrumentation = require('@opentelemetry/instrumentation');
var resources = require('@opentelemetry/resources');
var sdkLogs = require('@opentelemetry/sdk-logs');
var sdkTraceWeb = require('@opentelemetry/sdk-trace-web');
var utils = require('./utils.js');
var setupDefaultInstrumentations = require('./setupDefaultInstrumentations.js');
var webCommon = require('@opentelemetry/web-common');
var registry = require('./registry.js');
var defaultAttributeScrubbers = require('./defaultAttributeScrubbers.js');
var OTelPerformanceManager = require('../utils/PerformanceManager/OTelPerformanceManager.js');
var webSdkResource = require('../resources/webSdkResource.js');
var EmbraceDynamicConfigManager = require('../managers/EmbraceConfigManager/EmbraceDynamicConfigManager.js');
var EmbraceSDKFeaturesManager = require('../managers/EmbraceSDKFeaturesManager/EmbraceSDKFeaturesManager.js');
var EmbraceLimitManager = require('../managers/EmbraceLimitManager/EmbraceLimitManager.js');
var constants = require('../managers/EmbraceLimitManager/constants.js');
var EmbraceUserManager = require('../managers/EmbraceUserManager/EmbraceUserManager.js');
var userAPI = require('../api-users/userAPI.js');
var EmbraceSpanSessionManager = require('../managers/EmbraceSpanSessionManager/EmbraceSpanSessionManager.js');
var sessionAPI = require('../api-sessions/sessionAPI.js');
var EmbraceTraceManager = require('../managers/EmbraceTraceManager/EmbraceTraceManager.js');
var traceAPI = require('../api-traces/traceAPI.js');
var EmbraceNetworkSpanProcessor = require('../processors/EmbraceNetworkSpanProcessor/EmbraceNetworkSpanProcessor.js');
var UserSpanProcessor = require('../processors/UserSpanProcessor/UserSpanProcessor.js');
var SpanScrubProcessor = require('../processors/SpanScrubProcessor/SpanScrubProcessor.js');
var EmbraceSessionBatchedSpanProcessor = require('../processors/EmbraceSessionBatchedSpanProcessor/EmbraceSessionBatchedSpanProcessor.js');
var EmbraceTraceExporter = require('../exporters/EmbraceTraceExporter/EmbraceTraceExporter.js');
var EmbraceLogManager = require('../managers/EmbraceLogManager/EmbraceLogManager.js');
var logAPI = require('../api-logs/logAPI.js');
var IdentifiableSessionLogRecordProcessor = require('../processors/IdentifiableSessionLogRecordProcessor/IdentifiableSessionLogRecordProcessor.js');
var EmbraceLogRecordProcessor = require('../processors/EmbraceLogRecordProcessor/EmbraceLogRecordProcessor.js');
var UserLogRecordProcessor = require('../processors/UserLogRecordProcessor/UserLogRecordProcessor.js');
var LogRecordScrubProcessor = require('../processors/LogRecordScrubProcessor/LogRecordScrubProcessor.js');
var EmbraceLogExporter = require('../exporters/EmbraceLogExporter/EmbraceLogExporter.js');

const initSDK = ({ appID, appVersion, templateBundleID, resource = resources.Resource.empty(), spanExporters = [], logExporters = [], spanProcessors = [], propagator = null, defaultInstrumentationConfig, instrumentations = [], contextManager = null, logProcessors = [], attributeScrubbers = [], enableDefaultAttributeScrubbing = true, additionalQueryParamsToScrub = [], logLevel = api.DiagLogLevel.ERROR, embraceDataURL, embraceConfigURL, diagLogger = api.diag.createComponentLogger({
    namespace: 'embrace-sdk'
}), dynamicSDKConfigManager: providedDynamicSDKConfigManager, dynamicSDKConfig } = {
    appID: ''
})=>{
    try {
        const perf = new OTelPerformanceManager.OTelPerformanceManager();
        const initSDKStart = perf.getNowMillis();
        const existingSDK = registry.registry.registered();
        if (existingSDK !== null) {
            diagLogger.warn('SDK has already been successfully initialized, skipping this invocation of initSDK');
            return existingSDK;
        }
        api.diag.setLogger(new api.DiagConsoleLogger(), {
            logLevel
        });
        if (templateBundleID && templateBundleID.length !== 32) {
            throw new Error('templateBundleID should be 32 characters long');
        }
        const resourceWithWebSDKAttributes = resource.merge(webSdkResource.getWebSDKResource({
            diagLogger,
            appVersion,
            templateBundleID,
            pageSessionStorage: window.sessionStorage
        }));
        const sendingToEmbrace = !!appID && utils.isValidAppID(appID);
        if (!sendingToEmbrace && !logExporters.length && !spanExporters.length) {
            throw new Error('when the embrace appID is omitted then at least one logExporter or spanExporter must be set');
        }
        const userManager = setupUser();
        const enduserPseudoID = userManager.getEmbraceUserId();
        if (sendingToEmbrace && !enduserPseudoID) {
            throw new Error('userID is required when using Embrace exporter');
        }
        const dynamicConfigManager = providedDynamicSDKConfigManager ?? new EmbraceDynamicConfigManager.EmbraceDynamicConfigManager({
            appID,
            appVersion,
            embraceConfigURL,
            defaultConfig: dynamicSDKConfig,
            deviceId: enduserPseudoID
        });
        void dynamicConfigManager.refreshRemoteConfig();
        const sdkFeaturesManager = new EmbraceSDKFeaturesManager.EmbraceSDKFeaturesManager({
            dynamicConfigManager,
            deviceId: enduserPseudoID
        });
        if (!sdkFeaturesManager.isSDKEnabled()) {
            diagLogger.debug('SDK is disabled, skipping initialization.');
            return false;
        }
        const limitManager = new EmbraceLimitManager.EmbraceLimitManager(constants.DEFAULT_LIMITS);
        const spanSessionManager = setupSession({
            limitManager
        });
        const finalAttributeScrubbers = [
            ...enableDefaultAttributeScrubbing ? defaultAttributeScrubbers.getDefaultAttributeScrubbers(additionalQueryParamsToScrub) : [],
            ...attributeScrubbers
        ];
        const tracerProvider = setupTraces({
            sendingToEmbrace,
            appID,
            enduserPseudoID,
            resource: resourceWithWebSDKAttributes,
            spanSessionManager,
            userManager,
            spanExporters,
            spanProcessors,
            propagator,
            contextManager,
            limitManager,
            attributeScrubbers: finalAttributeScrubbers,
            embraceDataURL
        });
        const loggerProvider = setupLogs({
            sendingToEmbrace,
            appID,
            enduserPseudoID,
            resource: resourceWithWebSDKAttributes,
            userManager,
            logExporters,
            logProcessors,
            spanSessionManager,
            limitManager,
            attributeScrubbers: finalAttributeScrubbers,
            embraceDataURL
        });
        // NOTE: we require setupInstrumentation to run the last, after setupLogs and setupTraces. This is how OTel works wrt
        // the dependencies between instrumentations and global providers. We need the providers for tracers, and logs to be
        // setup before we enable instrumentations.
        instrumentation.registerInstrumentations({
            instrumentations: [
                ...instrumentations,
                setupDefaultInstrumentations.setupDefaultInstrumentations(defaultInstrumentationConfig)
            ]
        });
        diagLogger.info('successfully initialized the SDK');
        const sdkControl = {
            setDynamicConfig: (config)=>{
                dynamicConfigManager.setConfig(config);
            },
            flush: async ()=>{
                await tracerProvider.forceFlush();
                await loggerProvider.forceFlush();
            }
        };
        registry.registry.register(sdkControl);
        spanSessionManager.recordStartupDuration(perf.getNowMillis() - initSDKStart);
        return sdkControl;
    } catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown error.';
        diagLogger.error(`failed to initialize the SDK: ${message}`);
        return false;
    }
};
const setupUser = ()=>{
    const embraceUserManager = new EmbraceUserManager.EmbraceUserManager();
    userAPI.user.setGlobalUserManager(embraceUserManager);
    return embraceUserManager;
};
const setupSession = ({ limitManager })=>{
    const embraceSpanSessionManager = new EmbraceSpanSessionManager.EmbraceSpanSessionManager({
        limitManager
    });
    sessionAPI.session.setGlobalSessionManager(embraceSpanSessionManager);
    return embraceSpanSessionManager;
};
const setupTraces = ({ sendingToEmbrace, appID, enduserPseudoID, resource, spanSessionManager, userManager, spanExporters, spanProcessors = [], propagator = null, contextManager = null, limitManager, attributeScrubbers, embraceDataURL })=>{
    const embraceTraceManager = new EmbraceTraceManager.EmbraceTraceManager();
    traceAPI.trace.setGlobalTraceManager(embraceTraceManager);
    const finalSpanProcessors = [
        ...spanProcessors,
        webCommon.createSessionSpanProcessor(spanSessionManager),
        new EmbraceNetworkSpanProcessor.EmbraceNetworkSpanProcessor(),
        new UserSpanProcessor.UserSpanProcessor({
            userManager
        }),
        new SpanScrubProcessor.SpanScrubProcessor({
            attributeScrubbers
        })
    ];
    spanExporters?.forEach((exporter)=>{
        finalSpanProcessors.push(new sdkTraceWeb.BatchSpanProcessor(exporter));
    });
    if (sendingToEmbrace && appID && enduserPseudoID) {
        finalSpanProcessors.push(new EmbraceSessionBatchedSpanProcessor.EmbraceSessionBatchedSpanProcessor({
            exporter: new EmbraceTraceExporter.EmbraceTraceExporter({
                appID,
                embraceDataURL,
                userID: enduserPseudoID
            }),
            limitManager
        }));
    }
    const tracerProvider = new sdkTraceWeb.WebTracerProvider({
        resource,
        spanProcessors: finalSpanProcessors,
        spanLimits: {
            // Session properties are stored as attributes on the session span, add a
            // buffer here so that there is room for our internal attributes
            attributeCountLimit: constants.DEFAULT_LIMITS.maxAllowed.session_property * 2,
            attributePerEventCountLimit: 20,
            // Breadcrumbs are stored as events on the session span, add a
            // buffer here so that there is room for our internal events
            eventCountLimit: constants.DEFAULT_LIMITS.maxAllowed.breadcrumb * 2,
            attributeValueLengthLimit: 1024
        }
    });
    tracerProvider.register({
        contextManager,
        propagator
    });
    return tracerProvider;
};
const setupLogs = ({ sendingToEmbrace, appID, enduserPseudoID, resource, userManager, logExporters, logProcessors, spanSessionManager, limitManager, attributeScrubbers, embraceDataURL })=>{
    const embraceLogManager = new EmbraceLogManager.EmbraceLogManager({
        spanSessionManager,
        limitManager
    });
    logAPI.log.setGlobalLogManager(embraceLogManager);
    const loggerProvider = new sdkLogs.LoggerProvider({
        resource
    });
    const finalLogProcessors = [
        ...logProcessors,
        new IdentifiableSessionLogRecordProcessor.IdentifiableSessionLogRecordProcessor({
            spanSessionManager
        }),
        new EmbraceLogRecordProcessor.EmbraceLogRecordProcessor(),
        new UserLogRecordProcessor.UserLogRecordProcessor({
            userManager
        }),
        new LogRecordScrubProcessor.LogRecordScrubProcessor({
            attributeScrubbers
        })
    ];
    logExporters?.forEach((exporter)=>{
        finalLogProcessors.push(new sdkLogs.BatchLogRecordProcessor(exporter));
    });
    if (sendingToEmbrace && appID && enduserPseudoID) {
        finalLogProcessors.push(new sdkLogs.BatchLogRecordProcessor(new EmbraceLogExporter.EmbraceLogExporter({
            appID,
            embraceDataURL,
            userID: enduserPseudoID
        })));
    }
    for (const logProcessor of finalLogProcessors){
        loggerProvider.addLogRecordProcessor(logProcessor);
    }
    apiLogs.logs.setGlobalLoggerProvider(loggerProvider);
    return loggerProvider;
};

exports.initSDK = initSDK;
//# sourceMappingURL=initSDK.js.map
