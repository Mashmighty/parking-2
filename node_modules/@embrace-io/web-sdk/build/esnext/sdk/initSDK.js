import { diag, DiagConsoleLogger, DiagLogLevel } from '@opentelemetry/api';
import { logs } from '@opentelemetry/api-logs';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { Resource } from '@opentelemetry/resources';
import { LoggerProvider, BatchLogRecordProcessor } from '@opentelemetry/sdk-logs';
import { BatchSpanProcessor, WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import { isValidAppID } from './utils.js';
import { setupDefaultInstrumentations } from './setupDefaultInstrumentations.js';
import { createSessionSpanProcessor } from '@opentelemetry/web-common';
import { registry } from './registry.js';
import { getDefaultAttributeScrubbers } from './defaultAttributeScrubbers.js';
import { OTelPerformanceManager } from '../utils/PerformanceManager/OTelPerformanceManager.js';
import { getWebSDKResource } from '../resources/webSdkResource.js';
import { EmbraceDynamicConfigManager } from '../managers/EmbraceConfigManager/EmbraceDynamicConfigManager.js';
import { EmbraceSDKFeaturesManager } from '../managers/EmbraceSDKFeaturesManager/EmbraceSDKFeaturesManager.js';
import { EmbraceLimitManager } from '../managers/EmbraceLimitManager/EmbraceLimitManager.js';
import { DEFAULT_LIMITS } from '../managers/EmbraceLimitManager/constants.js';
import { EmbraceUserManager } from '../managers/EmbraceUserManager/EmbraceUserManager.js';
import { user } from '../api-users/userAPI.js';
import { EmbraceSpanSessionManager } from '../managers/EmbraceSpanSessionManager/EmbraceSpanSessionManager.js';
import { session } from '../api-sessions/sessionAPI.js';
import { EmbraceTraceManager } from '../managers/EmbraceTraceManager/EmbraceTraceManager.js';
import { trace } from '../api-traces/traceAPI.js';
import { EmbraceNetworkSpanProcessor } from '../processors/EmbraceNetworkSpanProcessor/EmbraceNetworkSpanProcessor.js';
import { UserSpanProcessor } from '../processors/UserSpanProcessor/UserSpanProcessor.js';
import { SpanScrubProcessor } from '../processors/SpanScrubProcessor/SpanScrubProcessor.js';
import { EmbraceSessionBatchedSpanProcessor } from '../processors/EmbraceSessionBatchedSpanProcessor/EmbraceSessionBatchedSpanProcessor.js';
import { EmbraceTraceExporter } from '../exporters/EmbraceTraceExporter/EmbraceTraceExporter.js';
import { EmbraceLogManager } from '../managers/EmbraceLogManager/EmbraceLogManager.js';
import { log } from '../api-logs/logAPI.js';
import { IdentifiableSessionLogRecordProcessor } from '../processors/IdentifiableSessionLogRecordProcessor/IdentifiableSessionLogRecordProcessor.js';
import { EmbraceLogRecordProcessor } from '../processors/EmbraceLogRecordProcessor/EmbraceLogRecordProcessor.js';
import { UserLogRecordProcessor } from '../processors/UserLogRecordProcessor/UserLogRecordProcessor.js';
import { LogRecordScrubProcessor } from '../processors/LogRecordScrubProcessor/LogRecordScrubProcessor.js';
import { EmbraceLogExporter } from '../exporters/EmbraceLogExporter/EmbraceLogExporter.js';

const initSDK = ({ appID, appVersion, templateBundleID, resource = Resource.empty(), spanExporters = [], logExporters = [], spanProcessors = [], propagator = null, defaultInstrumentationConfig, instrumentations = [], contextManager = null, logProcessors = [], attributeScrubbers = [], enableDefaultAttributeScrubbing = true, additionalQueryParamsToScrub = [], logLevel = DiagLogLevel.ERROR, embraceDataURL, embraceConfigURL, diagLogger = diag.createComponentLogger({
    namespace: 'embrace-sdk'
}), dynamicSDKConfigManager: providedDynamicSDKConfigManager, dynamicSDKConfig } = {
    appID: ''
})=>{
    try {
        const perf = new OTelPerformanceManager();
        const initSDKStart = perf.getNowMillis();
        const existingSDK = registry.registered();
        if (existingSDK !== null) {
            diagLogger.warn('SDK has already been successfully initialized, skipping this invocation of initSDK');
            return existingSDK;
        }
        diag.setLogger(new DiagConsoleLogger(), {
            logLevel
        });
        if (templateBundleID && templateBundleID.length !== 32) {
            throw new Error('templateBundleID should be 32 characters long');
        }
        const resourceWithWebSDKAttributes = resource.merge(getWebSDKResource({
            diagLogger,
            appVersion,
            templateBundleID,
            pageSessionStorage: window.sessionStorage
        }));
        const sendingToEmbrace = !!appID && isValidAppID(appID);
        if (!sendingToEmbrace && !logExporters.length && !spanExporters.length) {
            throw new Error('when the embrace appID is omitted then at least one logExporter or spanExporter must be set');
        }
        const userManager = setupUser();
        const enduserPseudoID = userManager.getEmbraceUserId();
        if (sendingToEmbrace && !enduserPseudoID) {
            throw new Error('userID is required when using Embrace exporter');
        }
        const dynamicConfigManager = providedDynamicSDKConfigManager ?? new EmbraceDynamicConfigManager({
            appID,
            appVersion,
            embraceConfigURL,
            defaultConfig: dynamicSDKConfig,
            deviceId: enduserPseudoID
        });
        void dynamicConfigManager.refreshRemoteConfig();
        const sdkFeaturesManager = new EmbraceSDKFeaturesManager({
            dynamicConfigManager,
            deviceId: enduserPseudoID
        });
        if (!sdkFeaturesManager.isSDKEnabled()) {
            diagLogger.debug('SDK is disabled, skipping initialization.');
            return false;
        }
        const limitManager = new EmbraceLimitManager(DEFAULT_LIMITS);
        const spanSessionManager = setupSession({
            limitManager
        });
        const finalAttributeScrubbers = [
            ...enableDefaultAttributeScrubbing ? getDefaultAttributeScrubbers(additionalQueryParamsToScrub) : [],
            ...attributeScrubbers
        ];
        const tracerProvider = setupTraces({
            sendingToEmbrace,
            appID,
            enduserPseudoID,
            resource: resourceWithWebSDKAttributes,
            spanSessionManager,
            userManager,
            spanExporters,
            spanProcessors,
            propagator,
            contextManager,
            limitManager,
            attributeScrubbers: finalAttributeScrubbers,
            embraceDataURL
        });
        const loggerProvider = setupLogs({
            sendingToEmbrace,
            appID,
            enduserPseudoID,
            resource: resourceWithWebSDKAttributes,
            userManager,
            logExporters,
            logProcessors,
            spanSessionManager,
            limitManager,
            attributeScrubbers: finalAttributeScrubbers,
            embraceDataURL
        });
        // NOTE: we require setupInstrumentation to run the last, after setupLogs and setupTraces. This is how OTel works wrt
        // the dependencies between instrumentations and global providers. We need the providers for tracers, and logs to be
        // setup before we enable instrumentations.
        registerInstrumentations({
            instrumentations: [
                ...instrumentations,
                setupDefaultInstrumentations(defaultInstrumentationConfig)
            ]
        });
        diagLogger.info('successfully initialized the SDK');
        const sdkControl = {
            setDynamicConfig: (config)=>{
                dynamicConfigManager.setConfig(config);
            },
            flush: async ()=>{
                await tracerProvider.forceFlush();
                await loggerProvider.forceFlush();
            }
        };
        registry.register(sdkControl);
        spanSessionManager.recordStartupDuration(perf.getNowMillis() - initSDKStart);
        return sdkControl;
    } catch (e) {
        const message = e instanceof Error ? e.message : 'Unknown error.';
        diagLogger.error(`failed to initialize the SDK: ${message}`);
        return false;
    }
};
const setupUser = ()=>{
    const embraceUserManager = new EmbraceUserManager();
    user.setGlobalUserManager(embraceUserManager);
    return embraceUserManager;
};
const setupSession = ({ limitManager })=>{
    const embraceSpanSessionManager = new EmbraceSpanSessionManager({
        limitManager
    });
    session.setGlobalSessionManager(embraceSpanSessionManager);
    return embraceSpanSessionManager;
};
const setupTraces = ({ sendingToEmbrace, appID, enduserPseudoID, resource, spanSessionManager, userManager, spanExporters, spanProcessors = [], propagator = null, contextManager = null, limitManager, attributeScrubbers, embraceDataURL })=>{
    const embraceTraceManager = new EmbraceTraceManager();
    trace.setGlobalTraceManager(embraceTraceManager);
    const finalSpanProcessors = [
        ...spanProcessors,
        createSessionSpanProcessor(spanSessionManager),
        new EmbraceNetworkSpanProcessor(),
        new UserSpanProcessor({
            userManager
        }),
        new SpanScrubProcessor({
            attributeScrubbers
        })
    ];
    spanExporters?.forEach((exporter)=>{
        finalSpanProcessors.push(new BatchSpanProcessor(exporter));
    });
    if (sendingToEmbrace && appID && enduserPseudoID) {
        finalSpanProcessors.push(new EmbraceSessionBatchedSpanProcessor({
            exporter: new EmbraceTraceExporter({
                appID,
                embraceDataURL,
                userID: enduserPseudoID
            }),
            limitManager
        }));
    }
    const tracerProvider = new WebTracerProvider({
        resource,
        spanProcessors: finalSpanProcessors,
        spanLimits: {
            // Session properties are stored as attributes on the session span, add a
            // buffer here so that there is room for our internal attributes
            attributeCountLimit: DEFAULT_LIMITS.maxAllowed.session_property * 2,
            attributePerEventCountLimit: 20,
            // Breadcrumbs are stored as events on the session span, add a
            // buffer here so that there is room for our internal events
            eventCountLimit: DEFAULT_LIMITS.maxAllowed.breadcrumb * 2,
            attributeValueLengthLimit: 1024
        }
    });
    tracerProvider.register({
        contextManager,
        propagator
    });
    return tracerProvider;
};
const setupLogs = ({ sendingToEmbrace, appID, enduserPseudoID, resource, userManager, logExporters, logProcessors, spanSessionManager, limitManager, attributeScrubbers, embraceDataURL })=>{
    const embraceLogManager = new EmbraceLogManager({
        spanSessionManager,
        limitManager
    });
    log.setGlobalLogManager(embraceLogManager);
    const loggerProvider = new LoggerProvider({
        resource
    });
    const finalLogProcessors = [
        ...logProcessors,
        new IdentifiableSessionLogRecordProcessor({
            spanSessionManager
        }),
        new EmbraceLogRecordProcessor(),
        new UserLogRecordProcessor({
            userManager
        }),
        new LogRecordScrubProcessor({
            attributeScrubbers
        })
    ];
    logExporters?.forEach((exporter)=>{
        finalLogProcessors.push(new BatchLogRecordProcessor(exporter));
    });
    if (sendingToEmbrace && appID && enduserPseudoID) {
        finalLogProcessors.push(new BatchLogRecordProcessor(new EmbraceLogExporter({
            appID,
            embraceDataURL,
            userID: enduserPseudoID
        })));
    }
    for (const logProcessor of finalLogProcessors){
        loggerProvider.addLogRecordProcessor(logProcessor);
    }
    logs.setGlobalLoggerProvider(loggerProvider);
    return loggerProvider;
};

export { initSDK };
//# sourceMappingURL=initSDK.js.map
